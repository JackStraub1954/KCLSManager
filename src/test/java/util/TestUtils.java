package util;

import static kcls_manager.database.DBConstants.AUTHORS_TABLE_NAME;
import static kcls_manager.database.DBConstants.COMMENTS_TABLE_NAME;
import static kcls_manager.database.DBConstants.LISTS_TABLE_NAME;
import static kcls_manager.database.DBConstants.TEST_DB_URL;
import static kcls_manager.database.DBConstants.TITLES_TABLE_NAME;
import static org.junit.jupiter.api.Assertions.fail;

import java.awt.Component;
import java.awt.Container;
import java.awt.Window;
import java.io.IOException;
import java.time.LocalDate;
import java.time.LocalTime;
import java.util.List;
import java.util.function.BiPredicate;
import java.util.logging.FileHandler;
import java.util.logging.Level;
import java.util.logging.LogManager;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;
import java.util.logging.XMLFormatter;

import javax.swing.AbstractButton;
import javax.swing.JDialog;
import javax.swing.JFrame;

import kcls_manager.database.DBServer;
import kcls_manager.main.Comment;
import kcls_manager.main.DataManager;
import kcls_manager.main.KCLSException;
import kcls_manager.main.LibraryItem;
import kcls_manager.main.Utils;

public class TestUtils
{
    /** Convenient predicate to find a component by component name. */
    public static final BiPredicate<Component,Object> nameFinder    = 
        (c,s) -> s.equals( c.getName() );
        
    /** Convenient predicate to find a button by its label. */
    public static final BiPredicate<Component,Object> textFinder    = 
        (c,s) -> c instanceof AbstractButton 
                 && s.equals( ((AbstractButton)c).getText() );
        
    private static final String loggerName  = TestUtils.class.getName();
    private static final Logger logger      = Logger.getLogger( loggerName );
    
    /**
     * Remove the console handler from the logging system
     * (log messages will no longer be written to stderr).
     * Write log message to file kcls_test.log.
     * 
     * @see #loggingInit(String, boolean)
     */
    public static void loggingInit()
    {
        loggingInit( "kcls_test.xml", false );
    }
    
    /**
     * Initialize logging configuration. 
     * A specific log file may be specified (em>pattern</em>)
     * and console logging may be turned off or on.
     * If <em>pattern</em> is null, no output file will be used.
     * If console logging is to be turned off,
     * it's not turned off until after configuration processing 
     * takes place, meaning that log messages generated by this
     * facility will be unconditionally written to the console.
     * 
     * If <em>pattern</em> ends in <em>.xml</em>
     * file logging formatter will be set to XMLFormatter,
     * otherwise it will be set to SimpleFormatter.
     * 
     * The root logger is set to logging level <em>info.</em>
     * 
     * @param pattern       name of file to log to; may be null
     * @param consoleOn     false to turn console logging off
     * 
     * @throws KCLSException if an error occurs
     * 
     * @see #loggingInit()
     */
    public static void loggingInit( String pattern, boolean consoleOn )
        throws KCLSException
    {
        Logger  root    = Logger.getLogger( "" );
        logger.info( "setting root logger level to info" );
        root.setLevel( Level.INFO );
        logger.info( "Logging to: " + pattern );
        if ( consoleOn )
        {
            logger.info( "console logging on" );
        }
        else
        {
            logger.info( "console logging off" );
            LogManager.getLogManager().reset();
        }
        try
        {
            if ( pattern != null )
            {
                FileHandler fileHandler = new FileHandler( pattern );
                if ( pattern.toLowerCase().endsWith( ".xml" ) )
                    fileHandler.setFormatter( new XMLFormatter() );
                else
                    fileHandler.setFormatter( new SimpleFormatter() );
                root.addHandler( fileHandler );
                logger.info( "Logging to: " + pattern );
                fileHandler.setLevel( Level.INFO );
            }
        }
        catch ( IOException | SecurityException exc )
        {
            String  message = "logging cofiguration failed";
            logger.severe(message);
            throw new KCLSException( message, exc );
        }
    }

    /**
     * Make the database nice and clean for new testing.
     * 
     * @param dbServer  represents the database connection
     */
    public static void truncateAllTables( DBServer dbServer )
    {
        String[]    allTables   = 
        {
            AUTHORS_TABLE_NAME,
            TITLES_TABLE_NAME,
            LISTS_TABLE_NAME,
            COMMENTS_TABLE_NAME
        };
        for ( String table : allTables )
            dbServer.truncateTable( table );
    }
    
    /**
     * Gets a DBServer instance.
     * This method is placed here to ensure that all tests
     * properly connect to the test database.
     * 
     * @return  DBServer instance, connected to test database.
     */
    public static DBServer getDBServer()
    {
        DBServer    server  = DataManager.getDBServer( TEST_DB_URL );
        return server;
    }
    
    /**
     * Suspend thread execution for a given number of milliseconds.
     * 
     * @param millis    the given number of milliseconds
     */
    public static void pause( long millis )
    {
        long    endTime = System.currentTimeMillis() + millis;
        while ( System.currentTimeMillis() < endTime )
        {
            try
            {
                Thread.sleep( endTime - System.currentTimeMillis() );
            }
            catch ( InterruptedException exc )
            {
                // not an error;
                // keep waiting until endTime is passed
            }
        }
    }

    /**
     * Get today's date. If the time is within 2 seconds of midnight
     * wait until midnight has passed before returning.
     * 
     * @return today's date, waiting for midnight if necessary
     */
    public static LocalDate nowAccountingForMidnight()
    {
        LocalTime   time    = LocalTime.now();
        LocalDate   now     = LocalDate.now();
        // if time is less than 1 seconds before midnight
        // wait for 2 seconds
        while ( time.getHour() == 11
            && time.getMinute() == 59
            && time.getSecond() >= 58
           )
        {
            pause( 2000 );
            time = LocalTime.now();
            now = LocalDate.now();
        }
        
        return now;
    }
    
    /**
     * Assert that two lists of LibraryItems are equal,
     * as determined by Utils.equals(List,List).
     * 
     * @param <T>       the type of the lists
     * @param expList   the expected list of values
     * @param actList   the actual list of values
     * 
     * @see kcls_manager.main.Utils#equals(List, List)
     */
    public static <T extends LibraryItem> void 
    assertListsEqual( List<T> expList, List<T> actList )
    {
        if ( !Utils.equals( expList, actList ) )
        {
            StringBuilder   bldr    = new StringBuilder();
            bldr.append( "expected: " ).append( expList )
                .append( " actual: " ).append( actList );
            fail( bldr.toString() );
        }
    }
    
    /**
     * Assert that two lists of LibraryItems are equal,
     * as determined by Utils.equals(List,List).
     * 
     * @param <T>       the type of the lists
     * @param expList   the expected list of values
     * @param actList   the actual list of values
     * 
     * @see kcls_manager.main.Utils#equals(List, List)
     */
    public static <T extends Comment> void 
    assertCommentsEqual( List<T> expList, List<T> actList )
    {
        if ( !Utils.equals( expList, actList ) )
        {
            StringBuilder   bldr    = new StringBuilder();
            bldr.append( "expected: " ).append( expList )
                .append( " actual: " ).append( actList );
            fail( bldr.toString() );
        }
    }
    
    /**
     * Obtains a Swing component by its name.
     * 
     * @param name  the name of the component to find
     * 
     * @return the target component, or null if not found
     */
    public static Component getComponent( String name )
    {
        Component   comp    = getComponent( nameFinder, name );
        return comp;
    }
    
    /**
     * Obtains a Swing component given an object and a predicate.
     * 
     * @param pred  the given predicate
     * @param obj   the given object
     * 
     * @return the target component, or null if not found
     */
    public static Component 
    getComponent( BiPredicate<Component,Object> pred, Object obj )
    {
        Component   comp    = null;
        Window[]    frames  = Window.getWindows();
        for ( int inx = 0 ; inx < frames.length && comp == null ; ++inx )
        {
            Window  frame   = frames[inx];
            if ( !frame.isDisplayable() )
                continue;
            if ( pred.test( frame, obj ) )
                comp = frame;
            else if ( frame instanceof JFrame )
            {
                Container   cont    = ((JFrame)frame).getContentPane();
                comp = getComponent( cont, pred, obj );
            }
            else if ( frame instanceof JDialog )
            {
                Container   cont    = ((JDialog)frame).getContentPane();
                comp = getComponent( cont, pred, obj );
            }
            else
                comp = getComponent( frame, pred, obj );
        }
        return comp;
    }
    
    /**
     * Finds a Swing component given a Container to search,
     * a predicate and an object. 
     * The Container is searched recursively.
     * 
     * @param container the given container
     * @param pred      the given predicate
     * @param obj       the given object
     * 
     * @return the target component, or null if not found
     */
    public static Component getComponent(
        Container container, 
        BiPredicate<Component,Object> pred, 
        Object obj
    )
    {
        Component       comp        = null;
        Component[]     children    = container.getComponents();
        int             numChildren = children.length;
        for ( int inx = 0 ; inx < numChildren && comp == null ; ++inx )
        {
            Component   test    = children[inx];
            if ( pred.test( test, obj ) )
                comp = test;
            else if ( test instanceof Container )
                comp = getComponent( (Container)test, pred, obj );
            else
                ;
        }
        return comp;
    }
}
